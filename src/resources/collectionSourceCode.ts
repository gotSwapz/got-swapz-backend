export const collectionSourceCode =
  '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/// @title IGotSwapzFactory\n/// @notice Minimal interface of the GotSwapzFactory contract, containing only the `requestRandomWords` function.\ninterface IGotSwapzFactory {\n    /// @notice Request random words to Chainlink.\n    /// @param numWords - Number of words requested.\n    /// @return requestId - VRF request ID.\n    function requestRandomWords(uint32 numWords)\n        external\n        returns (uint256 requestId);\n}\n\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    event URI(string value, uint256 indexed id);\n\n    /*//////////////////////////////////////////////////////////////\n                             ERC1155 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                             METADATA LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function uri(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC1155 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender],\n            "NOT_AUTHORIZED"\n        );\n\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, from, to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(\n                    msg.sender,\n                    from,\n                    id,\n                    amount,\n                    data\n                ) == ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, "LENGTH_MISMATCH");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender],\n            "NOT_AUTHORIZED"\n        );\n\n        // Storing these outside the loop saves ~15 gas per iteration.\n        uint256 id;\n        uint256 amount;\n\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n\n            // An array can\'t have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(\n                    msg.sender,\n                    from,\n                    ids,\n                    amounts,\n                    data\n                ) == ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, "LENGTH_MISMATCH");\n\n        balances = new uint256[](owners.length);\n\n        // Unchecked because the only math done is incrementing\n        // the array index counter which cannot possibly overflow.\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        returns (bool)\n    {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(\n                    msg.sender,\n                    address(0),\n                    id,\n                    amount,\n                    data\n                ) == ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n\n            // An array can\'t have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(\n                    msg.sender,\n                    address(0),\n                    ids,\n                    amounts,\n                    data\n                ) == ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n\n            // An array can\'t have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n}\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnerUpdated(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, "UNAUTHORIZED");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnerUpdated(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setOwner(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnerUpdated(msg.sender, newOwner);\n    }\n}\n\n/// @title GotSwapzCollection\n/// @notice NFT collection with capabilities to mint packages of random NFTs and swap NFTs with\n/// \t\tother NFT owners.\ncontract GotSwapzCollection is ERC1155, Owned {\n    // ======================= ERRORS ==============================\n\n    /// @notice The name of the collection cannot be an empty string.\n    error GotSwapzCollection_EmptyName();\n    /// @notice The URI cannot be an empty string.\n    error GotSwapzCollection_EmptyUri();\n    /// @notice The package units and package prices arrays must have the same length and not be empty.\n    error GotSwapzCollection_InvalidNumOfPackages();\n    /// @notice The rarity array must have between 1 and `_MAX_NFTS` items.\n    error GotSwapzCollection_InvalidRariryLength();\n    /// @notice The price of all packages must be greater than zero.\n    error GotSwapzCollection_InvalidPackagePrice();\n    /// @notice The number of units of all packages must be between 1 and `_MAX_PACKAGE_UNITS`.\n    error GotSwapzCollection_InvalidPackageUnits();\n    /// @notice The rarity valur of all NFTs must be between 1 and `_MAX_RARITY_VALUE`.\n    error GotSwapzCollection_InvalidRarityValue();\n    /// @notice The value sent does not match the package price.\n    error GotSwapzCollection_InvalidValueSent();\n    /// @notice The VRF request ID does not correspond to a pending order.\n    error GotSwapzCollection_PendingOrderNotFound();\n    /// @notice The number of items offered and demanded must be between 1 and `_MAX_SWAP_ITEMS`.\n    error GotSwapzCollection_InvalidNumberOfItems();\n    /// @notice The owner of the offered and demanded NFTs must be different.\n    error GotSwapzCollection_SenderIsReceiver();\n    /// @notice The address does not own all the NFTs of the array.\n    error GotSwapzCollection_NotOwnerOfAll();\n    /// @notice Only the creator of the offer is allowed to perform this action.\n    error GotSwapzCollection_NotOfferOwner();\n    /// @notice Only the recipient of the offer is allowed to perform this action.\n    error GotSwapzCollection_NotDemandedOwner();\n    /// @notice The offer is not in open state.\n    error GotSwapzCollection_NotOpenOffer();\n    /// @notice The swap does not exist.\n    error GotSwapzCollection_SwapNotFound();\n    /// @notice Only the factory contract is allowed to perform this action.\n    error GotSwapzCollection_SenderNotGotSwapzFactory();\n    /// @notice The tranfer of funds has failed.\n    error GotSwapzCollection_TransferFailed();\n\n    // ======================= ENUMS ===============================\n\n    /// @dev State of a swap.\n    /// \t 0 (OFFERED) - Open swap offer.\n    ///\t\t 1 (REJECTED) - Rejected by receiver of the offer.\n    ///\t\t 2 (CANCELLED) - Cancelled by creator of the offer.\n    ///\t\t 3 (EXECUTED) - Swap accepted and processed.\n    enum SwapState {\n        OFFERED,\n        REJECTED,\n        CANCELLED,\n        EXECUTED\n    }\n\n    // ======================= STRUCTS =============================\n\n    /// @dev Swap struct.\n    /// \t ownerA - Creator of the swap offer.\n    ///\t\t ownerB - Receiver of the swap offer.\n    ///\t\t nftsA - Array of NFTs offered by the creator.\n    ///\t\t nftsB - Array of NFTs demanded by the creator.\n    ///\t\t state - Current state of the swap.\n    struct Swap {\n        address ownerA;\n        address ownerB;\n        uint256[] nftsA;\n        uint256[] nftsB;\n        SwapState state;\n    }\n\n    // ======================= CONSTANTS ===========================\n\n    // Max number of package options allowed.\n    uint256 private constant _MAX_PACKAGES_OPTIONS = 8;\n    // Max number of units allowed in a package.\n    uint256 private constant _MAX_PACKAGE_UNITS = 100;\n    // Max number of NFTs allowed.\n    uint256 private constant _MAX_NFTS = 1000;\n    // Max value allowed for the rarity of a NFT.\n    uint256 private constant _MAX_RARITY_VALUE = 100;\n    // Max number of offered and demanded NFTs allowed for a swap.\n    uint256 private constant _MAX_SWAP_ITEMS = 100;\n    // Swap ID => Swap struct.\n    mapping(uint256 => Swap) private _swaps;\n\n    // ======================= IMMUTABLES ==========================\n\n    // Factory contract that created the collection.\n    IGotSwapzFactory private immutable _factory;\n    // Summatory of the rarity values of all NFTs used to process a random ID.\n    uint16 private immutable _raritySum;\n    // Service fee to be applied to package sales.\n    /// @notice Represents percentage with two decimal places (e.g. 125 = 1.25%).\n    uint256 private immutable _serviceFee;\n\n    // ======================= PUBLIC STORAGE ======================\n\n    // Name of the collection.\n    string public name;\n    // Last created swap ID.\n    uint256 public swapCounter;\n\n    // ======================= PRIVATE STORAGE =====================\n\n    // URI for all token types by relying on ID substitution.\n    string private _uri;\n    // Array of the package sizes of the collection.\n    uint8[] private _packageUnits;\n    // Array of the prices for the package sizes of the collection.\n    uint256[] private _packagePrices;\n    // Array of the rarity values (from 1 to `_MAX_RARITY_VALUE`) for each NFT of the collection.\n    // Each of the values represents the rarity of a specific NFT, corresponding the index 0 of the\n    // array to the NFT with ID = 1. The lower the value, the more rare that NFT is.\n    uint8[] private _rarity;\n    // Package number of units => Package price.\n    mapping(uint8 => uint256) private _packages;\n    // VRF request ID => Buyer address. Keeps track of pending (waiting for randomness) orders.\n    mapping(uint256 => address) private _pendingOrders;\n\n    // ======================= MODIFIERS ===========================\n\n    /// @dev Checks that all the `nftIds` are owned by `addr`.\n    modifier ownsAll(address addr, uint256[] calldata nftIds) {\n        uint256 nftIdsLength = nftIds.length;\n        for (uint256 i = 0; i < nftIdsLength; ) {\n            if (balanceOf[addr][nftIds[i]] == 0) {\n                revert GotSwapzCollection_NotOwnerOfAll();\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        _;\n    }\n\n    // ======================= EVENTS ==============================\n\n    /// @dev Emmited when a buyer opens an order.\n    event OrderCreated(address indexed buyer, uint8 units, uint256 requestId);\n\n    /// @dev Emmited when an open order is processed.\n    event OrderProcessed(\n        address indexed buyer,\n        uint256 requestId,\n        uint256[] nfts\n    );\n\n    /// @dev Emmited when a new swap offer is created.\n    event SwapOfferCreated(\n        uint256 indexed swapId,\n        address ownerA,\n        address ownerB,\n        uint256[] nftsA,\n        uint256[] nftsB\n    );\n\n    /// @dev Emmited when an existing swap changes its state.\n    event SwapOfferUpdated(uint256 swapId, SwapState state);\n\n    // ======================= CONSTRUCTOR =========================\n\n    /// @notice Constructor inherits Owned.\n    /// @param owner_ - Owner of the collection.\n    /// @param serviceFee_ - Service fee to be applied to package sales.\n    /// @param name_ - Name of the collection.\n    /// @param uri_ - IPFS URI of the collection.\n    /// @param packageUnits_ - Array of the package sizes of the collection.\n    /// @param packagePrices_ - Array of the prices for the package sizes of the collection.\n    /// @param rarity_ - Array of the rarity values for each NFT of the collection.\n    constructor(\n        address owner_,\n        uint256 serviceFee_,\n        string memory name_,\n        string memory uri_,\n        uint8[] memory packageUnits_,\n        uint256[] memory packagePrices_,\n        uint8[] memory rarity_\n    ) Owned(owner_) {\n        if (bytes(name_).length == 0) revert GotSwapzCollection_EmptyName();\n        if (bytes(uri_).length == 0) revert GotSwapzCollection_EmptyUri();\n        uint256 packageUnitsLength = packageUnits_.length;\n        if (\n            packageUnitsLength == 0 ||\n            packageUnitsLength > _MAX_PACKAGES_OPTIONS ||\n            packageUnitsLength != packagePrices_.length\n        ) revert GotSwapzCollection_InvalidNumOfPackages();\n        uint256 rarityLength = rarity_.length;\n        if (rarityLength == 0 || rarityLength > _MAX_NFTS)\n            revert GotSwapzCollection_InvalidRariryLength();\n\n        // Set state variables.\n        _factory = IGotSwapzFactory(msg.sender);\n        name = name_;\n        _uri = uri_;\n        _packageUnits = packageUnits_;\n        _packagePrices = packagePrices_;\n        _rarity = rarity_;\n\n        // Calculate and set _raritySum. Check for invalid rarity values.\n        uint16 raritySumLocal;\n        for (uint256 i = 0; i < rarityLength; ++i) {\n            uint8 rarityValue = rarity_[i];\n            if (rarityValue == 0 || rarityValue > _MAX_RARITY_VALUE)\n                revert GotSwapzCollection_InvalidRarityValue();\n            raritySumLocal += rarity_[i];\n        }\n        _raritySum = raritySumLocal;\n\n        // Set _packages mapping. Check for invalid package number of units of price.\n        for (uint256 i = 0; i < packageUnitsLength; ++i) {\n            uint256 packageUnits = packageUnits_[i];\n            if (packageUnits == 0 || packageUnits > _MAX_PACKAGE_UNITS)\n                revert GotSwapzCollection_InvalidPackageUnits();\n\n            uint256 packagePrice = packagePrices_[i];\n            if (packagePrice == 0)\n                revert GotSwapzCollection_InvalidPackagePrice();\n            _packages[packageUnits_[i]] = packagePrice;\n        }\n\n        // Set service fee. Value is checked in factory contract, so no need for additional validations.\n        _serviceFee = serviceFee_;\n    }\n\n    // ======================= GETTERS =============================\n\n    /// @notice Get collection URI. It relies on the token type ID substitution mechanism:\n    /// \t \thttps://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n    /// \t \tClients calling this function must replace the `\\{id\\}` substring with the actual token type ID.\n    /// @param id - ID of the NFT. This param is not used, but included in the function to comply with the EIP-1155.\n    /// @return _uri - Shared URI for all NFTs of the collection\n    function uri(uint256 id) public view override returns (string memory) {\n        return _uri;\n    }\n\n    /// @notice Get units and prices of collection\'s available packages.\n    /// @return packageUnits - Array of the package sizes of the collection.\n    /// @return packagePrices - Array of the prices for the package sizes of the collection.\n    function getPackageInfo()\n        external\n        view\n        returns (uint8[] memory packageUnits, uint256[] memory packagePrices)\n    {\n        packageUnits = _packageUnits;\n        packagePrices = _packagePrices;\n    }\n\n    /// @notice Get rarity values.\n    /// @return _rarity - Array of the rarity values for each NFT of the collection.\n    function getRarity() external view returns (uint8[] memory) {\n        return (_rarity);\n    }\n\n    // ======================= PURCHASE ============================\n\n    /// @notice Buy a package of random NFTs from the collection.\n    /// @param units - Number of units of the package to buy.\n    function buyPackage(uint8 units) external payable {\n        // Check if `units` matches a valid package size and value sent is equal to the price of the package.\n        if (msg.value == 0 || _packages[units] != msg.value)\n            revert GotSwapzCollection_InvalidValueSent();\n\n        // Request random words to factory contract and store the VRF request ID.\n        uint256 requestId = _factory.requestRandomWords(units);\n        _pendingOrders[requestId] = msg.sender;\n\n        // Send fee amount to the factory contract.\n        uint256 feeAmount = (msg.value * _serviceFee) / 10000;\n        (bool success, ) = address(_factory).call{value: feeAmount}("");\n        if (!success) revert GotSwapzCollection_TransferFailed();\n\n        emit OrderCreated(msg.sender, units, requestId);\n    }\n\n    /// @notice Process an open order. This function is to be called by the factory contract, once it has\n    ///\t\t\treceived the random words from Chainlink.\n    /// @param requestId - VRF request ID.\n    /// @param randomWords - Array of random words with a length equal to the number of units of the order.\n    function processOrder(uint256 requestId, uint256[] memory randomWords)\n        external\n    {\n        if (msg.sender != address(_factory))\n            revert GotSwapzCollection_SenderNotGotSwapzFactory();\n\n        address buyer = _pendingOrders[requestId];\n        if (buyer == address(0))\n            revert GotSwapzCollection_PendingOrderNotFound();\n\n        uint256 numWords = randomWords.length;\n        uint256[] memory tokenIds = new uint256[](numWords);\n        uint256[] memory amounts = new uint256[](numWords);\n\n        // Get random IDs from the list of random words. The chance of getting a specific NFT is determined\n        // by its corresponding value in the _rarity array.\n        for (uint256 i = 0; i < numWords; ++i) {\n            uint256 normalizedRandomNum = randomWords[i] % _raritySum;\n            uint16 currValue;\n            for (uint256 j = 0; j < _rarity.length; ++j) {\n                currValue += _rarity[j];\n                if (normalizedRandomNum < currValue) {\n                    tokenIds[i] = j + 1;\n                    amounts[i] = 1;\n                    break;\n                }\n            }\n        }\n\n        // Mint NFTs for the buyer of the package.\n        _batchMint(buyer, tokenIds, amounts, "");\n\n        // Update the order in the _pendingOrders mapping.\n        _pendingOrders[requestId] = address(0x0);\n\n        emit OrderProcessed(buyer, requestId, tokenIds);\n    }\n\n    // ======================= SWAP ================================\n\n    /// @notice Process an open order. This function is to be called by the factory contract, once it has\n    ///\t\t\treceived the random words from Chainlink.\n    /// @param nftsOffered - Array with the IDs of the NFTs offered by the creator of the swap offer.\n    /// @param nftsDemanded - Array with the IDs of the NFTs demanded by the creator of the swap offer.\n    /// @param to - Owner of the `nftsDemanded` to whom the offer is addressed.\n    /// @return swapId - ID of the new swap offer.\n    function createSwapOffer(\n        uint256[] calldata nftsOffered,\n        uint256[] calldata nftsDemanded,\n        address to\n    ) external ownsAll(to, nftsDemanded) returns (uint256 swapId) {\n        if (msg.sender == to) revert GotSwapzCollection_SenderIsReceiver();\n        uint256 nftsOfferedLength = nftsOffered.length;\n        uint256 nftsDemandedLength = nftsDemanded.length;\n        if (\n            nftsOfferedLength == 0 ||\n            nftsOfferedLength > _MAX_SWAP_ITEMS ||\n            nftsDemandedLength == 0 ||\n            nftsDemandedLength > _MAX_SWAP_ITEMS\n        ) revert GotSwapzCollection_InvalidNumberOfItems();\n\n        // Lock offered NFTs in the contract.\n        _lockNfts(nftsOffered);\n\n        // Create Swap struct and store it.\n        swapId = ++swapCounter;\n        _swaps[swapId] = Swap({\n            ownerA: msg.sender,\n            ownerB: to,\n            nftsA: nftsOffered,\n            nftsB: nftsDemanded,\n            state: SwapState.OFFERED\n        });\n\n        emit SwapOfferCreated(\n            swapId,\n            msg.sender,\n            to,\n            nftsOffered,\n            nftsDemanded\n        );\n    }\n\n    /// @notice Cancel an open swap offer. Only the creator of the swap offer is allowed.\n    /// @param swapId - ID of the swap to be cancelled.\n    function cancelSwapOffer(uint256 swapId) external {\n        Swap memory swap = _swaps[swapId];\n        if (swap.ownerA != msg.sender)\n            revert GotSwapzCollection_NotOfferOwner();\n        if (_swaps[swapId].state != SwapState.OFFERED)\n            revert GotSwapzCollection_NotOpenOffer();\n\n        // Unlock offered NFTs.\n        _unlockNfts(msg.sender, swap.nftsA);\n\n        // Update state of the Swap.\n        _swaps[swapId].state = SwapState.CANCELLED;\n\n        emit SwapOfferUpdated(swapId, SwapState.CANCELLED);\n    }\n\n    /// @notice Reject an open swap offer. Only the receiver of the swap is allowed.\n    /// @param swapId - ID of the swap to be rejected.\n    function rejectSwapOffer(uint256 swapId) external {\n        Swap memory swap = _swaps[swapId];\n        if (swap.ownerB != msg.sender)\n            revert GotSwapzCollection_NotDemandedOwner();\n        if (_swaps[swapId].state != SwapState.OFFERED)\n            revert GotSwapzCollection_NotOpenOffer();\n\n        // Unlock offered NFTs.\n        _unlockNfts(swap.ownerA, swap.nftsA);\n\n        // Update state of the Swap.\n        _swaps[swapId].state = SwapState.REJECTED;\n\n        emit SwapOfferUpdated(swapId, SwapState.REJECTED);\n    }\n\n    /// @notice Accept an open swap offer. Only the receiver of the swap is allowed.\n    /// @param swapId - ID of the swap to be accepted.\n    function acceptSwapOffer(uint256 swapId) external {\n        Swap memory swap = _swaps[swapId];\n        if (swap.ownerB != msg.sender)\n            revert GotSwapzCollection_NotDemandedOwner();\n        if (_swaps[swapId].state != SwapState.OFFERED)\n            revert GotSwapzCollection_NotOpenOffer();\n\n        // Transfer ownerB\'s NFTs to ownerA.\n        uint256 id;\n        uint256 nftIdsLength = swap.nftsB.length;\n        for (uint256 i = 0; i < nftIdsLength; ) {\n            id = swap.nftsB[i];\n            balanceOf[msg.sender][id]--;\n            balanceOf[swap.ownerA][id]++;\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Transfer ownerA\'s locked NFTs to ownerB.\n        _unlockNfts(msg.sender, swap.nftsA);\n\n        // Update state of the Swap.\n        _swaps[swapId].state = SwapState.EXECUTED;\n\n        emit SwapOfferUpdated(swapId, SwapState.EXECUTED);\n    }\n\n    /// @notice Get all the data of a Swap.\n    /// @param swapId - ID of the Swap to be retrieved.\n    /// @return ownerA - Creator of the swap offer.\n    /// @return ownerB - Receiver of the swap offer.\n    /// @return nftsA - Array of NFTs offered by the creator.\n    /// @return nftsB - Array of NFTs demanded by the creator.\n    /// @return state - Current state of the swap.\n    function getSwap(uint256 swapId)\n        external\n        view\n        returns (\n            address ownerA,\n            address ownerB,\n            uint256[] memory nftsA,\n            uint256[] memory nftsB,\n            SwapState state\n        )\n    {\n        if (swapId == 0 || swapId > swapCounter)\n            revert GotSwapzCollection_SwapNotFound();\n\n        Swap memory swap = _swaps[swapId];\n        ownerA = swap.ownerA;\n        ownerB = swap.ownerB;\n        nftsA = swap.nftsA;\n        nftsB = swap.nftsB;\n        state = swap.state;\n    }\n\n    // ======================= WITHDRAWAL ==========================\n\n    /// @notice Withdraws all the balance of the contract. Only owner is allowed.\n    function withdraw() external onlyOwner {\n        (bool success, ) = msg.sender.call{value: address(this).balance}("");\n        if (!success) revert GotSwapzCollection_TransferFailed();\n    }\n\n    // ======================= PRIVATE FUNCTIONS ===================\n\n    /// @notice Lock offered NFTs in the contract.\n    /// @param nftIds - Array with the NFTs IDs to be locked.\n    function _lockNfts(uint256[] calldata nftIds)\n        private\n        ownsAll(msg.sender, nftIds)\n    {\n        uint256 id;\n        uint256 nftIdsLength = nftIds.length;\n\n        for (uint256 i = 0; i < nftIdsLength; ) {\n            id = nftIds[i];\n            balanceOf[msg.sender][id]--;\n            balanceOf[address(this)][id]++;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Send back to `tokenOwner` the offered NFTs previusly locked in the contract.\n    /// @param tokenOwner - Owner of the NFTs.\n    /// @param nftIds - Array with the NFTs IDs to be unlocked.\n    function _unlockNfts(address tokenOwner, uint256[] memory nftIds) private {\n        uint256 id;\n        uint256 nftIdsLength = nftIds.length;\n\n        for (uint256 i = 0; i < nftIdsLength; ) {\n            id = nftIds[i];\n            balanceOf[address(this)][id]--;\n            balanceOf[tokenOwner][id]++;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n';
